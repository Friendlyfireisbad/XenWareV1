_G.FOV = 0
_G.Prediction = (0.01)
_G.AimKey = false
_G.Sensitivity = 0
_G.Key = false
_G.FOVL = 90
local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()


local Window = OrionLib:MakeWindow({Name = "Universal Xenware Aimbot/Aimlock", HidePremium = false, SaveConfig = true, ConfigFolder = "Xenware universal config"})


local Tab = Window:MakeTab({
	Name = "Main",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})

Tab:AddLabel("Aimlock")
Tab:AddButton({
	Name = "AimLock",
	Callback = function()
        aimlock()
           
            end
    
})


Tab:AddTextbox({
    Name = "Sensitivity",
    Default = "",
    TextDisappear = true,
    Callback = function(Value)
        print(Value)
        _G.Sensitivity = Value
    end      
})

Tab:AddTextbox({
    Name = "AimKey",
    Default = "",
    TextDisappear = true,
    Callback = function(Value)
        print(Value)
        _G.Key = Value
    end      
})

Tab:AddSlider({
    Name = "Aimlokc Fov",
    Min = 0,
    Max = 500,
    Default = 0,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "Fov",
    Callback = function(Value)
        _G.FOVL = (Value)
    end    
})


Tab:AddLabel("SilentAim")

Tab:AddButton({
	Name = "SilentAim",
	Callback = function()

        silentaim()
    end     
    })
    
    Tab:AddTextbox({
        Name = "Keybind",
        Default = "",
        TextDisappear = true,
        Callback = function(Value)
            print(value)
            _G.AimKey = (Value)
        end      
    })

    Tab:AddTextbox({
        Name = "Prediction",
        Default = "",
        TextDisappear = true,
        Callback = function(Value)
            _G.Prediction =  (Value)
        end      
    })

    Tab:AddSlider({
        Name = "Fov",
        Min = 0,
        Max = 500,
        Default = 0,
        Color = Color3.fromRGB(255,255,255),
        Increment = 1,
        ValueName = "Fov",
        Callback = function(Value)
            _G.FOV = (Value)
        end    
    })
    

  



OrionLib:Init()


        

function aimlock()
    spawn(function()
     --// Preventing Multiple Processes

     pcall(function()
        getgenv().Aimbot.Functions:Exit()
    end)
    
    --// Environment
    
    getgenv().Aimbot = {}
    local Environment = getgenv().Aimbot
    
    --// Services
    
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local HttpService = game:GetService("HttpService")
    local TweenService = game:GetService("TweenService")
    local StarterGui = game:GetService("StarterGui")
    local Players = game:GetService("Players")
    local Camera = game:GetService("Workspace").CurrentCamera
    
    --// Variables
    
    
    local LocalPlayer = Players.LocalPlayer
    local Title = "Aim lock"
    local FileNames = {"Aimbot", "Configuration.json", "Drawing.json"}
    local RequiredDistance = math.huge
    local Typing = false
    local Running = false
    local Animation = nil
    local ServiceConnections = {RenderSteppedConnection = nil, InputBeganConnection = nil, InputEndedConnection = nil, TypingStartedConnection = nil, TypingEndedConnection = nil}
    
    --// Script Settings
    
    Environment.Settings = {
        SendNotifications = true,
        SaveSettings = false, -- Re-execute upon changing
        ReloadOnTeleport = true,
        Enabled = true,
        TeamCheck = false,
        AliveCheck = true,
        WallCheck = false, -- Laggy
        Sensitivity = tonumber(_G.Sensitivity), -- Animation length (in seconds) before fully locking onto target
        TriggerKey = _G.Key,
        Toggle = false,
        LockPart = "Head" -- Body part to lock on
    
        
    }
    
    
    
    Environment.FOVSettings = {
        Enabled = true,
        Visible = true,
        Amount = tonumber(_G.FOVL),
        Color = "255, 255, 255",
        LockedColor = "255, 70, 70",
        Transparency = 0.5,
        Sides = 60,
        Thickness = 1,
        Filled = false
    }
    
    Environment.FOVCircle = Drawing.new("Circle")
    Environment.Locked = nil
    
    --// Core Functions
    
    local function Encode(Table)
        if Table and type(Table) == "table" then
            local EncodedTable = HttpService:JSONEncode(Table)
    
            return EncodedTable
        end
    end
    
    local function Decode(String)
        if String and type(String) == "string" then
            local DecodedTable = HttpService:JSONDecode(String)
    
            return DecodedTable
        end
    end
    
    local function GetColor(Color)
        local R = tonumber(string.match(Color, "([%d]+)[%s]*,[%s]*[%d]+[%s]*,[%s]*[%d]+"))
        local G = tonumber(string.match(Color, "[%d]+[%s]*,[%s]*([%d]+)[%s]*,[%s]*[%d]+"))
        local B = tonumber(string.match(Color, "[%d]+[%s]*,[%s]*[%d]+[%s]*,[%s]*([%d]+)"))
    
        return Color3.fromRGB(R, G, B)
    end
    
    local function SendNotification(TitleArg, DescriptionArg, DurationArg)
        if Environment.Settings.SendNotifications then
            StarterGui:SetCore("SendNotification", {
                Title = TitleArg,
                Text = DescriptionArg,
                Duration = DurationArg
            })
        end
    end
    
    --// Functions
    
    local function SaveSettings()
        if Environment.Settings.SaveSettings then
            if isfile(Title.."/"..FileNames[1].."/"..FileNames[2]) then
                writefile(Title.."/"..FileNames[1].."/"..FileNames[2], Encode(Environment.Settings))
            end
    
            if isfile(Title.."/"..FileNames[1].."/"..FileNames[3]) then
                writefile(Title.."/"..FileNames[1].."/"..FileNames[3], Encode(Environment.FOVSettings))
            end
        end
    end
    
    local function GetClosestPlayer()
        if Environment.Locked == nil then
            if Environment.FOVSettings.Enabled then
                RequiredDistance = Environment.FOVSettings.Amount
            else
                RequiredDistance = math.huge
            end
    
            for _, v in next, Players:GetPlayers() do
                if v ~= LocalPlayer then
                    if v.Character[Environment.Settings.LockPart] then
                        if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
                        if Environment.Settings.AliveCheck and v.Character.Humanoid.Health <= 0 then continue end
                        if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end
    
                        local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
                        local Distance = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(Vector.X, Vector.Y)).Magnitude
    
                        if Distance < RequiredDistance and OnScreen then
                            RequiredDistance = Distance
                            Environment.Locked = v
                        end
                    end
                end
            end
        elseif (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
            Environment.Locked = nil
            Animation:Cancel()
            Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
        end
    end
    
    --// Typing Check
    
    ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
        Typing = true
    end)
    
    ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
        Typing = false
    end)
    
    --// Create, Save & Load Settings
    
    if Environment.Settings.SaveSettings then
        if not isfolder(Title) then
            makefolder(Title)
        end
    
        if not isfolder(Title.."/"..FileNames[1]) then
            makefolder(Title.."/"..FileNames[1])
        end
    
        if not isfile(Title.."/"..FileNames[1].."/"..FileNames[2]) then
            writefile(Title.."/"..FileNames[1].."/"..FileNames[2], Encode(Environment.Settings))
        else
            Environment.Settings = Decode(readfile(Title.."/"..FileNames[1].."/"..FileNames[2]))
        end
    
        if not isfile(Title.."/"..FileNames[1].."/"..FileNames[3]) then
            writefile(Title.."/"..FileNames[1].."/"..FileNames[3], Encode(Environment.FOVSettings))
        else
            Environment.Visuals = Decode(readfile(Title.."/"..FileNames[1].."/"..FileNames[3]))
        end
    
        coroutine.wrap(function()
            while wait(10) do
                SaveSettings()
            end
        end)()
    else
        if isfolder(Title) then
            delfolder(Title)
        end
    end
    
    local function Load()
        ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
            if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
                Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
                Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
                Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
                Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
                Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
                Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
                Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
                Environment.FOVCircle.Position = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
            else
                Environment.FOVCircle.Visible = false
            end
    
            if Running and Environment.Settings.Enabled then
                GetClosestPlayer()
    
                if Environment.Settings.Sensitivity > 0 then
                    Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
                    Animation:Play()
                else
                    Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
                end
    
                Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.LockedColor)
            end
        end)
    
        ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
            if not Typing then
                pcall(function()
                    if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
                        if Environment.Settings.Toggle then
                            Running = not Running
    
                            if not Running then
                                Environment.Locked = nil
                                Animation:Cancel()
                                Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
                            end
                        else
                            Running = true
                        end
                    end
                end)
    
                pcall(function()
                    if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
                        if Environment.Settings.Toggle then
                            Running = not Running
    
                            if not Running then
                                Environment.Locked = nil
                                Animation:Cancel()
                                Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
                            end
                        else
                            Running = true
                        end
                    end
                end)
            end
        end)
    
        ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
            if not Typing then
                pcall(function()
                    if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
                        if not Environment.Settings.Toggle then
                            Running = false
                            Environment.Locked = nil
                            Animation:Cancel()
                            Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
                        end
                    end
                end)
    
                pcall(function()
                    if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
                        if not Environment.Settings.Toggle then
                            Running = false
                            Environment.Locked = nil
                            Animation:Cancel()
                            Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
                        end
                    end
                end)
            end
        end)
    end
    
    --// Functions
    
    Environment.Functions = {}
    
    function Environment.Functions:Exit()
        SaveSettings()
    
        for _, v in next, ServiceConnections do
            v:Disconnect()
        end
    
        Environment.FOVCircle:Remove()
    
        getgenv().Aimbot.Functions = nil
        getgenv().Aimbot = nil
    end
    
    function Environment.Functions:Restart()
        SaveSettings()
    
        for _, v in next, ServiceConnections do
            v:Disconnect()
        end
    
        Environment.FOVCircle:Remove()
    
        Load()
    end
    
    function Environment.Functions:ResetSettings()
        Environment.Settings = {
            SendNotifications = true,
            SaveSettings = true, -- Re-execute upon changing
            ReloadOnTeleport = true,
            Enabled = true,
            TeamCheck = false,
            AliveCheck = true,
            WallCheck = false,
            Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
            TriggerKey = "MouseButton2",
            Toggle = false,
            LockPart = "Head" -- Body part to lock on
        }
    
        Environment.FOVSettings = {
            Enabled = true,
            Visible = true,
            Amount = 90,
            Color = "255, 255, 255",
            LockedColor = "255, 70, 70",
            Transparency = 0.5,
            Sides = 60,
            Thickness = 1,
            Filled = false
        }
    
        SaveSettings()
    
        for _, v in next, ServiceConnections do
            v:Disconnect()
        end
    
        Load()
    end
    
    --// Support Check
    
    if not Drawing or not writefile or not makefolder then
        SendNotification(Title, "Your exploit does not support this script", 3); return
    end
    
    --// Load
    
    Load(); SendNotification(Title, "Aimlock script successfully loaded! ", 5)
end)
end
    

function silentaim()
    spawn(function()
     
        
        
      --FORTNITE BATTLE PASS
  
      --Holdi: I just shit out my ass.
        
        local SilentAim = true
        local LocalPlayer = game:GetService("Players").LocalPlayer
        local Players = game:GetService("Players")
        local Mouse = LocalPlayer:GetMouse()
        local Camera = game:GetService("Workspace").CurrentCamera
        hookmetamethod = hookmetamethod
        Drawing = Drawing
        
        local FOV_CIRCLE = Drawing.new("Circle") 
        
        FOV_CIRCLE.Visible = true
        FOV_CIRCLE.Filled = false
        FOV_CIRCLE.Thickness = 1
        FOV_CIRCLE.Transparency = 1
        FOV_CIRCLE.Color = Color3.new(0, 1, 0)
        FOV_CIRCLE.Radius = tonumber(_G.FOV)
        spawn(function()
            while wait(0.01) do
                FOV_CIRCLE.Radius = tonumber(_G.FOV)
            end
        end)
        FOV_CIRCLE.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        
        Options = {
            Torso = "HumanoidRootPart";
            Head = "Head";
        }
        
        local function MoveFovCircle()
            pcall(function()
                local DoIt = true
                spawn(function()
                    while DoIt do task.wait()
                        FOV_CIRCLE.Position = Vector2.new(Mouse.X, (Mouse.Y + 36))
                    end
                end)
            end)
        end coroutine.wrap(MoveFovCircle)()
        
        Mouse.KeyDown:Connect(function(KeyPressed)
            if KeyPressed == (_G.AimKey:lower()) then
                if SilentAim == false then
                    FOV_CIRCLE.Color = Color3.new(0, 1, 0)
                    SilentAim = true
                elseif SilentAim == true then
                    FOV_CIRCLE.Color = Color3.new(1, 0, 0)
                    SilentAim = false
                end
            end
        end)
        
        local oldIndex = nil 
        oldIndex = hookmetamethod(game, "__index", function(self, Index)
            if self == Mouse and (Index == "Hit") then 
                local Distance = 9e9
                local Targete = nil
                if SilentAim then
                    
                    for _, v in pairs(Players:GetPlayers()) do 
                        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("Humanoid").Health > 0 then
                            local Enemy = v.Character	
                            local CastingFrom = CFrame.new(Camera.CFrame.Position, Enemy[Options.Torso].CFrame.Position) * CFrame.new(0, 0, -4)
                            local RayCast = Ray.new(CastingFrom.Position, CastingFrom.LookVector * 9000)
                            local World, ToSpace = workspace:FindPartOnRayWithIgnoreList(RayCast, {LocalPlayer.Character:FindFirstChild("Head")})
                            local RootWorld = (Enemy[Options.Torso].CFrame.Position - ToSpace).magnitude
                            if RootWorld < 4 then
                                local RootPartPosition, Visible = Camera:WorldToScreenPoint(Enemy[Options.Torso].Position)
                                if Visible then
                                    local Real_Magnitude = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(RootPartPosition.X, RootPartPosition.Y)).Magnitude
                                    if Real_Magnitude < Distance and Real_Magnitude < FOV_CIRCLE.Radius then
                                        Distance = Real_Magnitude
                                        Targete = Enemy
                                    end
                                end
                            end
                        end
                    end
                end
                
                if Targete ~= nil and Targete[Options.Torso] and Targete:FindFirstChild("Humanoid").Health > 0 then
                    if SilentAim then
                        local ShootThis = Targete[Options.Torso] -- or Options.Head
                        local Predicted_Position = ShootThis.CFrame + (ShootThis.Velocity * _G.Prediction + Vector3.new(0,-1,0)) --  (-1) = Less blatant
                        return ((Index == "Hit" and Predicted_Position))
                    end
                end
                
            end
            return oldIndex(self, Index)
        end)
    
    
    end)
  
    end
